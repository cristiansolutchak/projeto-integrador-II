/app.py{
    resumo:
        Arquivo responsável por gerenciar o back-end do site.
    passo a passo:
    Primeiramente importamos a classe Flask - classe que gerará o cérebro do site, ele controla quase todo o back-end - e as funções render_template - responsável por 'ler' o arquivo html, permitindo assim que trabalhemos com arquivos distintos - e request, responsável por enviar ao beck-end os dados passados no formulário web - todos esses módulos da bibliotéca flask, após isso importamos o database, ele é responsável por salvar os dados no bando de dados.
    Após realizar as importações, declaramos a variavel app, o cérebro do site, responsável pelo 'gerenciamento' da url, ela será uma instância da classe Flask, e como parametros, enviamos a informação que nosso arquivo é o principal, após isso passamos os parâmetros static_folder e template_folder, que são as pastas estaticas('que contém as imagens, HTMLs e CSSs) e template onde estará o modelo do nosso site.
    Depois de declarar a variavel app, demos uma chave secreta a ela, permitindo assim que possamos salvar dados no banco de dados, e instanciamos o banco de dados na variável bd, nela apenas passamos o nome do banco de dados, já que grande parte das informações já estão pre definidas na classe que será explicada posteriormente.
    Em seguda, definimos que no index(página inicial) será chamada a função index, por meio do método @app.route('/'), na função index teremos 2 condições iniciais, a primeira para que possamos coletar o ip, comparando se existe algo no request.environ.get('HTTP_X_FORWARDED_FOR') em que o request.environ retorna todo o WSGI 'Web Server Gateway Interface' que é a camada que fica entre o servido e a aplicação web e então coletamos o HTTP_X_FORWARDED_FOR que é um cabeçalho padrão para identificar o endereço IP de origem de um cliente que se conecta a um servidor web por meio de um servidor proxy mas caso o HTTP_X_FORWARDED_FOR ser igual a None então coletamos o REMOTE_ADDR que contém o endereço IP do Host remoto que fez a requisição. Após isso, executamos a segunda comparação onde comparamos se request.args é diferente de 0 - request.args contém as váriaveis passadas via AJAX, portanto coso não haja nenhum valor, isso significa que não é uma requisição AJAX - caso request.args seja diferente de 0 isso significa que, por meio de um submmit do tipo GET, estão sendo passados valores e então salvamos no banco de dados. quando todas as comparações estiverem completas, então enviamos o arquivos index.html para o usuário por meio da função render_template.
    Ao concluir isso, para obtermos uma maior velocidade de desenvolvimento, criamos um app.run que, por segurança, é executado se o arquivo executado é o principal e ativamos o modo debug que após alterarmos salvarmos as alterações de algum código com a extenção .py, o servidor é reiniciado, porém ao alterarmos um arquivo que roda ao lado do usuário (HTML, JS e CSS) bem como definimos o host, que permite que outros usuários contectados na mesma rede possam entrar no site.
}

/module/database.py{
    resumo:
        Arquivo responsável por criar a classe que controlará o banco de dados do site.
    passo a passo:
        Inicialmente é necessário importar as dependências que são: pymysql - bibliotéca que consegue interagir com o banco de dados - e datetime - para conseguir o horário atual.
        Após isso criamos a classe Database(instanciada no arquivo app.py), nela definimos um iniciador que necessita de alguns valores para poder ser criada: database - que contém o nome do banco de dados que será usado -, user - que contém o nome do usuário do database, ele é predefinido como root -, passwd - que contém a senha do usuário do banco de dados, predefinido como string vazia -, port - a porta em que o banco de dados está sendo rodado, predefinida como 3306-, charset - é o tipo de caracteres que será usado, predefinido como utf8mb4 em que utf8 permite caracteres especias da língua portuguesa e mb4 indica que não será necessário converter estes caracteres-, após coletar estes dados, else serão atribuidos em um atributo cujo nome é dados em forma de tupla. Depois criamos um método chamado connect, ele acessará o atibuto dados e retornara a conecção com o banco de dados e um cursor - onde será executadas as querys MYSQL-. Logo depois, criamos um método salvar onde são necessários os dados que serão salvos - nome, email e comentário, a variável dados será do tipo werkzeug.datastructures.ImmutableMultiDict - e o ip do usuário, após coletar estes dados, definimos uma variavel horario que conterá o horário atual no formato aa-mm-dd-hh-mm-ss-msms, como iremos salvar apenas o ano, mes, dia, hora, minuto e segundo, não milisegundos, portanto primeiramente transformamos o dado que é retornado do tipo datetime.datetime para String e depois disso coletamos os caracteres que estão entre os indices 0 e 19, depois disso, chamamos o método connect que retorna uma conecção MYSQL - salvo na variável con - e um cursor, salvo em uma variável que leva seu nome, após concluido, definimos na variável sql a query que será executada no banco de dados, que será "INSERT INTO opinioes VALUES (DEFAULT, \'%s\', \'%s\', \'%s\',\'%s\', \'%s\')", usamos %s que é um metodo de interpolações de string, em cada %s conterá um tipo de dado, depois da declaração, iniciams um try, para tratar possíveis erros, nele executamos a query com o método cursor.cursor(sql%(dados['nome'], dados['email'], dados['comentario'], str(ip), horario)) - em que a tupla após o % são os dados que serão adicionados na string -, caso a query seja executada com sucesso, realizaremos um commit e retornamos a string 'Mensagem enviada com sucesso!'- apenas para depurtação-, caso ocorra um erro, mostraremos o erro - apenas para depurtação -, realizamos um rollback - não salvamos os dados pela metade - e criamos um erro do tipo str com o conteúdo 'Ocorreu um erro ao enviar a mensagem!' e independentemente do que ocorrer, fechamos a conecção.
}